// Generated by LiveScript 1.6.0
var group;
group = {
  h: {},
  g: {},
  m: 1,
  init: function(){
    return this.m = 1, this.g = {}, this.h = {}, this;
  },
  groups: function(){
    var ret, remap, k, ref$, v;
    ret = [];
    remap = 1;
    for (k in ref$ = this.g) {
      v = ref$[k];
      if (this.g[k].idx === +k) {
        this.g[k].id = remap;
        remap++;
        ret.push(this.g[k]);
      }
    }
    for (k in ref$ = this.g) {
      v = ref$[k];
      this.g[k].id = this.g[this.g[k].idx].id;
    }
    return ret;
  },
  getGroups: function(){
    var k, ref$, v, ret;
    this.groups();
    for (k in ref$ = this.g) {
      v = ref$[k];
      this.g[k].members = [];
    }
    for (k in ref$ = this.h) {
      v = ref$[k];
      this.g[this.g[this.h[k]].idx].members.push(+k);
    }
    ret = [];
    for (k in ref$ = this.g) {
      v = ref$[k];
      if (+k === v.idx) {
        ret.push(v);
      }
    }
    return ret;
  },
  add: function(i){
    var m;
    m = this.h[i] != null
      ? this.h[i]
      : this.h[i] = this.m;
    if (!this.g[m]) {
      this.g[m] = {
        idx: m
      };
    }
    if (m === this.m) {
      return this.m++;
    }
  },
  join: function(i, j){
    var mg, this$ = this;
    mg = Math.min(this.h[i] || this.m, this.h[j] || this.m);
    if (!this.g[mg]) {
      this.g[mg] = {
        idx: mg
      };
    }
    [i, j].map(function(it){
      if (this$.h[it]) {
        this$.g[this$.h[it] || this$.m] = this$.g[mg];
      }
      return this$.h[it] = mg;
    });
    if (mg === this.m) {
      this.m++;
    }
    return this.groups();
  }
};
// Generated by LiveScript 1.6.0
var parsePath;
parsePath = function(path, trianglify){
  var ref$, shape, hole, svg, ds, paths, shapes, intersect, i$, to$, i, j$, to1$, j, gs, len$, g, base, len1$, idx, p, ret, pts, faces;
  trianglify == null && (trianglify = false);
  ref$ = [[], []], shape = ref$[0], hole = ref$[1];
  svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  ref$ = svg.style;
  ref$.position = 'absolute';
  ref$.opacity = 0;
  ref$.zIndex = -1;
  ref$.top = 0;
  document.body.appendChild(svg);
  ds = [];
  paths = path.replace(/Z/g, 'z').split('z').filter(function(it){
    return it;
  }).map(function(it){
    var path, box, len, pts, i$, step$, to$, i, p, sum, j;
    ds.push(it);
    path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', it);
    svg.appendChild(path);
    box = path.getBoundingClientRect();
    len = path.getTotalLength();
    pts = [];
    for (i$ = 0, to$ = len + 1, step$ = len ? len / 200 : 1; step$ < 0 ? i$ >= to$ : i$ <= to$; i$ += step$) {
      i = i$;
      p = path.getPointAtLength(i);
      pts.push(p.x * 0.005 - 0.8, 0.1 - p.y * 0.02);
    }
    sum = 0;
    for (i$ = 0, to$ = pts.length - 2; i$ < to$; i$ += 2) {
      i = i$;
      j = (i + 2) % pts.length;
      sum += (pts[j] - pts[i]) / (pts[j + 1] + pts[i + 1]);
    }
    return {
      path: path,
      box: box,
      dir: sum > 0,
      data: pts,
      size: box.width * box.height
    };
  }).filter(function(it){
    return it;
  });
  shapes = [];
  shape = null;
  intersect = function(p1, p2){
    var skip, ref$, b1, b2, i$, m, isInside, j$, to$, k, x, y, inside, k$, to1$, i, j, xi, yi, xj, yj;
    skip = 0;
    skip = skip * 2 + 2;
    ref$ = [p1.box, p2.box], b1 = ref$[0], b2 = ref$[1];
    if (!(b1.x < b2.x + b2.width && b1.x + b1.width > b2.x && b1.y < b2.y + b2.height && b1.y + b1.height > b2.y)) {
      return false;
    }
    for (i$ = 0; i$ <= 1; ++i$) {
      m = i$;
      isInside = true;
      ref$ = [p2, p1], p1 = ref$[0], p2 = ref$[1];
      for (j$ = 0, to$ = p1.data.length; skip < 0 ? j$ > to$ : j$ < to$; j$ += skip) {
        k = j$;
        ref$ = [p1.data[k], p1.data[k + 1]], x = ref$[0], y = ref$[1];
        inside = false;
        for (k$ = 0, to1$ = p2.data.length; skip < 0 ? k$ > to1$ : k$ < to1$; k$ += skip) {
          i = k$;
          j = (i + skip) % p2.data.length;
          ref$ = [p2.data[i], p2.data[i + 1]], xi = ref$[0], yi = ref$[1];
          ref$ = [p2.data[j], p2.data[j + 1]], xj = ref$[0], yj = ref$[1];
          if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
            inside = !inside;
          }
        }
        isInside = isInside && inside;
      }
      if (isInside) {
        return true;
      }
    }
    return isInside;
  };
  group.init();
  for (i$ = 0, to$ = paths.length; i$ < to$; ++i$) {
    i = i$;
    group.add(i);
  }
  for (i$ = 0, to$ = paths.length; i$ < to$; ++i$) {
    i = i$;
    for (j$ = i + 1, to1$ = paths.length; j$ < to1$; ++j$) {
      j = j$;
      if (intersect(paths[i], paths[j])) {
        group.join(i, j);
      }
    }
  }
  gs = group.getGroups();
  if (trianglify) {
    for (i$ = 0, len$ = gs.length; i$ < len$; ++i$) {
      g = gs[i$];
      shape = {
        shape: [],
        hole: [],
        holeIdx: []
      };
      base = g.members.map(fn$);
      base.sort(fn1$);
      base = base[0];
      for (j$ = 0, len1$ = (ref$ = g.members).length; j$ < len1$; ++j$) {
        idx = ref$[j$];
        p = paths[idx];
        if (p === base) {
          shape.shape = shape.shape.concat(p.data);
        } else {
          shape.holeIdx.push(shape.hole.length / 2);
          shape.hole = shape.hole.concat(p.data);
        }
      }
      shape.holeIdx = shape.holeIdx.map(fn2$);
      shapes.push(shape);
    }
    ret = {
      faces: [],
      pts: [],
      groups: []
    };
    g = 1;
    for (i$ = 0, len$ = shapes.length; i$ < len$; ++i$) {
      shape = shapes[i$];
      pts = shape.shape.concat(shape.hole);
      faces = earcut(pts, shape.holeIdx);
      faces = faces.map(fn3$);
      ret.faces = ret.faces.concat(faces);
      ret.pts = ret.pts.concat(pts);
      for (j$ = 0, to$ = pts.length / 2; j$ < to$; ++j$) {
        i = j$;
        ret.groups.push(g);
      }
      g++;
    }
    svg.parentNode.removeChild(svg);
    return ret;
  } else {
    ret = [];
    for (i$ = 0, len$ = gs.length; i$ < len$; ++i$) {
      g = gs[i$];
      ret.push(g.members.map(fn4$).join('z'));
    }
    return ret;
  }
  function fn$(it){
    return paths[it];
  }
  function fn1$(a, b){
    return b.size - a.size;
  }
  function fn2$(it){
    return it + shape.shape.length / 2;
  }
  function fn3$(it){
    return it + ret.pts.length / 2;
  }
  function fn4$(i){
    return ds[i];
  }
};
